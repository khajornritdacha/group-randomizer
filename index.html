<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <form id="file-form">
      <input type="file" id="input-file" />
      <input type="submit" value="Upload" />
    </form>
    <!-- <script src="index.js" type="module" defer></script> -->
    <script type="module">
      import * as xlsx from "./xlsx.mjs";

      const GROUP = 13;
      const DAY = 6;
      let member = 0;
      const ROUND = 3;
      let MAX_MEMBER = 0;
      const SAMPLE_ROUND = 10;
      const data = [];
      async function processForm(e) {
        if (e.preventDefault) e.preventDefault();

        console.log("File uploaded");

        const file_form = document.getElementById("input-file");
        if (!file_form.files.length) {
          console.log("No file selected");
          return false;
        }

        const file = file_form.files[0];
        const raw_sheet = await file.arrayBuffer();
        /* raw_sheet is an ArrayBuffer */
        const workbook = xlsx.read(raw_sheet);

        // Extract member data
        // id start from 1
        for (let i = 2; ; i++) {
          if (!workbook.Sheets["database"][`A${i}`]) break;
          data.push({
            names: workbook.Sheets["database"][`A${i}`].v,
            roles: workbook.Sheets["database"][`D${i}`].v,
            baan: workbook.Sheets["database"][`E${i}`].v,
            ex_camp: workbook.Sheets["database"][`F${i}`].v,
            id: i - 1,
            leader_round: workbook.Sheets["database"][`J${i}`]?.v,
          });
          member++;
        }
        MAX_MEMBER = Math.ceil(member / GROUP);

        // Insert database sheet
        const out_wb = xlsx.utils.book_new();
        xlsx.utils.book_append_sheet(
          out_wb,
          workbook.Sheets["database"],
          "database"
        );

        const { groups, group_for_member, group_leaders } = random_group();
        create_group_assign_sheet(out_wb);
        insert_group_to_wb(out_wb, group_for_member);

        create_group_leader_sheet(out_wb);
        insert_group_leader_to_wb(out_wb, group_leaders);

        // if (!("control" in workbook.Sheets)) {
        //   console.log("Creating control sheet");
        //   modify_control_sheet(workbook);
        // }
        // const group_assign = generate_group_assign();
        // const out_ws = xlsx.utils.aoa_to_sheet(group_assign);
        // xlsx.utils.book_append_sheet(workbook, out_ws, "group_assign");
        xlsx.writeFile(out_wb, "output.xlsx");
        return false;
      }

      /**
       *
       * @param {xlsx.WorkBook} wb
       */
      function create_group_assign_sheet(wb) {
        const group_assign = [
          [
            "ชื่อ",
            "โครง",
            "บ้าน",
            "เป็นชาวค่ายเก่า",
            ...Array.from({ length: DAY }, (_, i) => `วันที่ ${i + 1}`),
          ],
        ];
        for (let i = 1; i <= member; i++) {
          group_assign.push([
            { t: "n", f: `=database!A${i + 1}` },
            {
              t: "n",
              f: `=VLOOKUP(A${i + 1},database!$A$2:$I${member + 1}, 4, 0)`,
            },
            {
              t: "n",
              f: `=VLOOKUP(A${i + 1},database!$A$2:$I${member + 1}, 5, 0)`,
            },
            {
              t: "n",
              f: `=2-VLOOKUP(A${i + 1},database!$A$2:$I${member + 1}, 6, 0)`,
            },
          ]);
        }
        xlsx.utils.book_append_sheet(
          wb,
          xlsx.utils.aoa_to_sheet(group_assign),
          "group_assign"
        );
      }

      /**
       * Assign group leader
       * @param {xlsx.WorkBook} wb
       */
      function create_group_leader_sheet(wb) {
        const group_leader = [
          [
            "group/day",
            ...Array.from({ length: DAY }, (_, i) => `วันที่ ${i + 1}`),
          ],
        ];
        for (let i = 1; i <= GROUP; i++) {
          group_leader.push([i]);
        }
        xlsx.utils.book_append_sheet(
          wb,
          xlsx.utils.aoa_to_sheet(group_leader),
          "group_leader"
        );
      }

      /**
       * Random best possible group
       * @returns {{groups: number[][], group_leaders: string[][], err: number}}
       */
      function random_group() {
        const samples = [];
        for (let i = 0; i < SAMPLE_ROUND || samples.length === 0; i++) {
          const { groups, group_for_member, group_leaders } = sample_group();
          if (!validate_group(groups)) continue;
          const err = calculate_error_score(groups);
          samples.push({ groups, group_for_member, group_leaders, err });
        }
        const min_err = Math.min(...samples.map((s) => s.err));
        const idx = samples.findIndex((s) => s.err === min_err);
        if (idx === -1) console.warn("No valid group");
        else console.log(`Minimum error of group: ${min_err}`);
        return samples[idx];
      }

      /**
       * Generate random group and return 3 values
       * 1. Group indexes by group number
       * 2. Group indexes by member number
       * 3. Group leaders by group number
       * @returns {{groups: Object[][], group_for_member: number[][], group_leaders: string[][]}}
       */
      function sample_group() {
        const group_for_member = Array.from({ length: member }, (_, i) => []);
        shuffle(data);
        const group_leaders = Array.from({ length: GROUP }, (_, i) =>
          Array.from({ length: DAY }, (_, i) => "")
        );
        const groups = Array.from({ length: GROUP }, (_, i) => []);
        const cat = Array.from({ length: ROUND + 1 }, (_, i) => []);
        data.forEach((d, i) => {
          const leader_round = d.leader_round;
          if (!leader_round) cat[ROUND].push(d);
          else cat[leader_round - 1].push(d);
        });
        for (let g = 0; g < GROUP; g++) {
          for (let r = 0; r < ROUND; r++) {
            for (let d = 0; d < DAY; d++) {
              const group_id = calculate_group_id(g, r, d);
              if (
                cat[r][g].leader_round &&
                Math.floor(d / 2) === cat[r][g].leader_round - 1
              ) {
                if (group_leaders[g][d]) console.warn("Duplicate leader");
                group_leaders[g][d] = cat[r][g].names;
              }
              groups[group_id - 1].push(cat[r][g]);
              group_for_member[cat[r][g].id - 1].push(group_id);
            }
          }
          if (g < cat[ROUND].length) {
            for (let d = 0; d < DAY; d++) {
              const group_id = calculate_group_id(g, ROUND, d);
              groups[group_id - 1].push(cat[ROUND][g]);
              group_for_member[cat[ROUND][g].id - 1].push(group_id);
            }
          }
        }
        return {
          groups,
          group_for_member,
          group_leaders,
        };
      }

      function calculate_error_score(groups) {
        return 0;
      }

      /**
       * Returns true if group is valid
       * @param {Object[][]} groups
       * @returns {boolean}
       */
      function validate_group(groups) {
        return true;
      }

      /**
       * Calculate group id
       * @param {number} g
       * @param {number} r
       * @param {number} d
       * @returns {number}
       */
      function calculate_group_id(g, r, d) {
        if (r === 0) r = MAX_MEMBER;
        return ((g + r * d) % GROUP) + 1;
      }

      /**
       * Shuffle array
       * @param {any[]} array
       * @returns {any[]}
       */
      function shuffle(array) {
        let currentIndex = array.length,
          randomIndex;

        // While there remain elements to shuffle.
        while (currentIndex > 0) {
          // Pick a remaining element.
          randomIndex = Math.floor(Math.random() * currentIndex);
          currentIndex--;

          // And swap it with the current element.
          [array[currentIndex], array[randomIndex]] = [
            array[randomIndex],
            array[currentIndex],
          ];
        }

        return array;
      }

      /**
       * Assign group to group assign sheet
       * @param {xlsx.WorkBook} wb
       */
      function insert_group_to_wb(wb, groups) {
        xlsx.utils.sheet_add_aoa(wb.Sheets["group_assign"], groups, {
          origin: "E2",
        });
      }

      /**
       * Assign group leader to group leader sheet
       * @param {xlsx.WorkBook} wb
       * @param {string[][]} group_leaders
       */
      function insert_group_leader_to_wb(wb, group_leaders) {
        xlsx.utils.sheet_add_aoa(wb.Sheets["group_leader"], group_leaders, {
          origin: "B2",
        });
      }

      function modify_control_sheet(wb) {
        const control = [];
        const max_col_member = xlsx.utils.encode_col(3 + DAY);
        for (let i = 1, row = 2; i <= member; i++) {
          for (let j = 1; j <= member; j++, row++) {
            control.push([
              {
                t: "n",
                f: `=COUNTIF(D${row}:${xlsx.utils.encode_col(
                  2 + DAY
                )}${row},"TRUE")`,
              },
              { t: "n", f: `=database!A${i + 1}` },
              { t: "n", f: `=database!A${j + 1}` },
              ...Array.from({ length: DAY }, (_, i) => ({
                t: "n",
                f: `=EXACT(VLOOKUP($B${row},group_assign!$A$2:$${max_col_member}${
                  member + 1
                }, ${
                  5 + i
                }, 0),VLOOKUP($C${row},group_assign!$A$2:$${max_col_member}${
                  member + 1
                }, ${5 + i}, 0))`,
              })),
            ]);
          }
        }
        xlsx.utils.sheet_add_aoa(wb.Sheets["control"], control, {
          origin: "A2",
        });
      }

      const form = document.getElementById("file-form");
      if (form.attachEvent) {
        form.AttachEvent("submit", processForm);
      } else {
        form.addEventListener("submit", processForm);
      }
    </script>
  </body>
</html>
